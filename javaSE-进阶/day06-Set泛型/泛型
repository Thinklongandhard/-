泛型

   该机制允许在编译时检测到非法的类型，它的本质是参数化类型，
   也就是说操作的数据类型被指定为一个参数
   
   参数化类型：
      将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型
	 （这种参数类型可以用在类，方法和接口中，分别被称为泛型类，
	    泛型方法，泛型接口）
		
泛型的定义格式：
   <类型> 指定一种类型的格式，这里的类型可以看成是形参
   <类型1，类型2...>  指定多种类型的格式，多种类型之间用逗号隔开
           这里的类型可以看成是形参。将来具体调用的时候给定的类型可以
		   看出是实参，并且实参的类型只能是引用数据类型
		   
	泛型的好处：
	    把运行事情的问题提前到了编译期间
		避免了强制类型转换
		
泛型类：
   定义格式： 
      修饰符 class 类名<类型>{}
	  
	  范例：public class Generic<T>{}
	      此处T可以随便写为任意标识，常见的如T,E,K,V等形式的参数
		  常用于表示泛型
		  
泛型方法：
    泛型方法的定义格式：
	    格式：修饰符<类型>返回值类型 方法名（类型 变量名）{}
		范例：
		    public <T> void show(T t){ }
			
泛型接口
    泛型接口的定义格式：
	    格式：修饰符 interface 接口名<类型>{ }
		范例：public interface Generic<T>{ }
		
类型通配符：
    为了表示各种泛型List的父类，可以使用类型通配符
	   类型通配符：<?>
	   List<?>:表示元素类型未知的List，它的元素可以匹配任何的类型
	   这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中
	   
	如果说我们不希望List<?>是任何泛型List的父类，只希望它代表某一类泛型List的父类，
	可以使用类型通配符的上线
	   类型通配符上限<?extends 类型>
	   List<?extends Number>: 它表示的类型是Number或者其子类型
	   
	除了可以指定类型通配符的上线，我们也可以指定类型通配符的下限
	   类型通配符下限<?super类型>
	   List<?super Number> : 表示的类型是Number或者其父类型
	   
	   
可变参数：
    可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了
	
	格式：
	   修饰符 返回值类型 方法名(数据类型...变量名){ }
	   
	范例：  
	    public static int sum(int... a){ }
		
[注意：
     这里的变量其实是一个数组
	 如果一个方法有多个参数，包含可变参数，可变参数要放在最后
]


可变参数的使用：
    Arrays工具类中有一个静态方法：
	   public static <T> List <T> asList<T...a>:
	    //返回由指定数组支持的固定大小的列表
		//返回的集合不能做增删操作，可以做修改操作
	   
	List接口中有一个静态方法：【该方法在JDK9版本以后实现】
	   public static <E>List<E> of(E...elements):
	    //返回包含任意数量元素的不可变列表
		//返回的集合不能做增删改操作
	
	Set接口中有一个静态方法： 【该方法在JDK9版本以后实现】
	   public static <E>Set<E> of(E...elements):
	    //返回一个包含任意数量参数的不可变集合
		//在给元素的时候，不能给重复的元素
		//返回的集合不能做增删操作，没有修改的方法